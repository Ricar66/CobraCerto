// Prisma Schema for CobraCerto SaaS
// Multi-tenant billing and collections management

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Tenant (Company/Organization using the SaaS)
model Tenant {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?
  plan      TenantPlan @default(STARTER)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users         User[]
  clients       Client[]
  invoices      Invoice[]
  reminderRules ReminderRule[]

  @@index([email])
  @@map("tenants")
}

enum TenantPlan {
  STARTER
  PRO
  BUSINESS
}

// User (belongs to a Tenant)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  role      UserRole
  active    Boolean  @default(true)
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([email])
  @@map("users")
}

enum UserRole {
  ADMIN
  MANAGER
}

// Client (customer of the Tenant)
model Client {
  id        String   @id @default(cuid())
  name      String
  email     String
  phone     String?
  document  String?  // CPF/CNPJ
  address   String?  @db.Text
  notes     String?  @db.Text
  active    Boolean  @default(true)
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoices Invoice[]

  @@index([tenantId])
  @@index([email])
  @@map("clients")
}

// Invoice (Cobran√ßa/Fatura)
model Invoice {
  id          String        @id @default(cuid())
  clientId    String
  tenantId    String
  amount      Decimal       @db.Decimal(10, 2)
  dueDate     DateTime
  paidAt      DateTime?
  status      InvoiceStatus @default(PENDING)
  description String        @db.Text
  notes       String?       @db.Text

  // Recurrence fields
  recurrence  Recurrence    @default(NONE)
  nextRunAt   DateTime?
  parentId    String?       // Original invoice if this was auto-generated

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  client  Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  tenant  Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  events  InvoiceEvent[]

  @@index([tenantId])
  @@index([clientId])
  @@index([status])
  @@index([dueDate])
  @@index([nextRunAt])
  @@map("invoices")
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

enum Recurrence {
  NONE
  WEEKLY
  MONTHLY
  YEARLY
}

// Invoice Event (log/history)
model InvoiceEvent {
  id          String    @id @default(cuid())
  invoiceId   String
  type        EventType
  description String    @db.Text
  metadata    String?   @db.Text // JSON string for extra data
  createdAt   DateTime  @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([createdAt])
  @@map("invoice_events")
}

enum EventType {
  CREATED
  UPDATED
  PAID
  CANCELLED
  REMINDER_SENT
  RENEGOTIATED
  NOTE_ADDED
}

// Reminder Rules (configurable per tenant)
model ReminderRule {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  daysBefore  Int?     // Days before due date (3, 1, 0)
  daysAfter   Int?     // Days after due date (3, 7, 15)
  active      Boolean  @default(true)
  emailSubject String  @db.Text
  emailBody    String  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@map("reminder_rules")
}

// Email Outbox (queue for sending emails)
model EmailOutbox {
  id          String      @id @default(cuid())
  to          String
  subject     String      @db.Text
  body        String      @db.Text
  status      EmailStatus @default(QUEUED)
  attempts    Int         @default(0)
  lastError   String?     @db.Text
  sentAt      DateTime?
  scheduledAt DateTime    @default(now())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([status])
  @@index([scheduledAt])
  @@map("email_outbox")
}

enum EmailStatus {
  QUEUED
  SENT
  FAILED
}
